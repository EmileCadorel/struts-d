module servlib.application.Application;import std.outbuffer, std.conv;import std.digest.crc, std.file, std.stdio, std.zip;import servlib.utils.lexer, std.container;import servlib.utils.Singleton;import servlib.utils.XMLoader;import servlib.utils.exception;import std.path;import servlib.utils.SoLoader;import servlib.application.StrutsLoader;class ApplicationLoader {    void load (string arch) {	try {	    string ext = extension (arch);	    if (ext != ".dar")		assert (false, "TODO, exception pas bonne extension");	    Application app = new Application (arch);	    app.expand ();	    string manifestPath = app.manifest;	    string dir = arch[0 .. arch.length - ext.length];		    	    Manifest man = new Manifest (manifestPath);	    foreach (it ; man.libs) {		SoLoader.instance.load (app.root ~ it);	    }	    StrutsLoader.load (app.root ~ man.config, app.root);	    	} catch (Exception erro) {	    writeln (erro.toString);	}    }            private {	this () {}	     }        mixin Singleton!ApplicationLoader;}class Manifest  {    this (string manifest) {	this.manifest = manifest;	this.root = XMLoader.root (manifest);	this._parse_file ();    }        string config () {	return this._config;    }    string [] libs () {	return this._libs;    }        private {	void _parse_file () {	    if (this.root.name.name != "manifest") 		throw new ManifestError (this.root);	    foreach (child ; this.root.childs) {		this._load_data (child);	    }	}		void _load_data (Balise b) {	    if (b.childs.length != 0) throw new ManifestError (b);	    if (b.name.name == "lib")		this._load_lib (b);	    else if (b.name.name == "struts")		this._load_struts (b);	    else		throw new ManifestError (b);	}	void _load_lib (Balise b) {	    if (b.attrs.length == 1) {		foreach (key, value ; b.attrs) {		    if (key.name == "path") _libs ~= value;		    else throw new ManifestError (b);		}	    } else throw new ManifestError (b);	}	void _load_struts (Balise b) {	    writeln ("ici");	    if (b.attrs.length == 1 && config is null) {		foreach (key, value ; b.attrs) {		    if (key.name == "path") _config = value;				    else throw new ManifestError (b);		}	    } else throw new ManifestError (b);	}		string manifest;	string _config = null;	string[] _libs;	Balise root;	    }        }class Application {    this (string archName) {	if (exists (archName)) {	    	    this.archFile = new ZipArchive (read (archName));	    this.archName = archName;	} else {	    assert (false, "fichier inexistant");	}    }    void expand () {	if (!std.file.exists (ROOTDIR))	    std.file.mkdir (ROOTDIR);	foreach (name, am; archFile.directory) {	    makeDir (ROOTDIR ~ name);	    if (!exists (ROOTDIR ~ name)) {		archFile.expand (am);		std.file.write (ROOTDIR ~ name, am.expandedData);			    }	    	    if ((ROOTDIR ~ name).length < _root.length || _root.length == 0)		_root = ROOTDIR ~ name;	}    }    string root () {	return this._root;    }        string manifest () {	return this._manifest;    }        private void makeDir (string list) {	string total;	LexerString lexer = new LexerString (list);	lexer.setKeys (make!(Array!string)(["/"]));	Word word;	while (lexer.getNext (word)) {	    total ~= word.str;	    if (word.str == "MANIFEST.xml")		this._manifest = total;	    if (word.str == "/") {		if (!exists (total)) {		    std.file.mkdir (total);		}	    }	}    }        override string toString () {		OutBuffer buf = new OutBuffer;	foreach (name, am; archFile.directory) {	    buf.write (name ~ " : ");	    buf.write (to!string (am.expandedSize));	    buf.write ("\n");	}	return buf.toString ();    }        private {		immutable string ROOTDIR = "deploy/";	ZipArchive archFile;	string archName;	string _manifest;	string _root;	    }}