module servlib.application.Application;import std.outbuffer, std.conv;import std.digest.crc, std.file, std.stdio, std.zip;import servlib.utils.lexer, std.container;import servlib.utils.Singleton;import servlib.utils.xml;import servlib.utils.exception;import std.path;import servlib.utils.SoLoader;import servlib.application.StrutsLoader;import servlib.application.Manifest;import std.string;/** Singleton permettant le chargement d'une archive */class ApplicationLoader {    /**     Charge une archive et renseigne les autres elements statique du serveur de la configuration de l'archive     Params:     arch, le path de l'archive a charger     */    void load (string arch) {	try {	    string ext = extension (arch);	    if (ext != ".dar")		throw new WrongExt (arch);	    Application app = new Application (arch);	    app.expand ();	    string manifestPath = app.manifest;	    string dir = arch[0 .. arch.length - ext.length];		    	    Manifest man = new Manifest (manifestPath);	    foreach (it ; man.libs) {		SoLoader.instance.load (app.root ~ it);	    }	    StrutsLoader.load (app.root ~ man.config, app.root);	    	} catch (Exception erro) {	    writeln (erro.toString);	}    }            private {	this () {}	     }        mixin Singleton!ApplicationLoader;}/** Classe permettant le desarchivage*/class Application {    /**     Charge l'archive     Params:     archName, le nom de l'archive a charger     Throws:     WrongExt     */    this (string archName) {	if (exists (archName)) {	    try {		this.archFile = new ZipArchive (read (archName));		this.archName = archName;	    } catch (Exception mod) {		throw new WrongExt (archName);	    }	} else {	    throw new WrongExt (archName);	}    }    /**     Desarchive l'application, le resultat sera dans le dossier ROOTDIR     */    void expand () {	if (!std.file.exists (ROOTDIR))	    std.file.mkdir (ROOTDIR);	foreach (name, am; archFile.directory) {	    makeDir (ROOTDIR ~ name);	    if (!exists (ROOTDIR ~ name)) {		archFile.expand (am);		std.file.write (ROOTDIR ~ name, am.expandedData);			    }	    	    if ((ROOTDIR ~ name).length < _root.length || _root.length == 0)		_root = ROOTDIR ~ name;	}    }    /**     Retourne l'emplacement de l'archive     */    string root () {	return this._root;    }    /**     Retourne le path du fichier manifest     */    string manifest () {	return this._manifest;    }    /**     Creer tout les dossier non existant dans un path     */    private void makeDir (string list) {	string total;	LexerString lexer = new LexerString (list);	lexer.setKeys (make!(Array!string)(["/"]));	Word word;	while (lexer.getNext (word)) {	    total ~= word.str;	    if (toUpper (word.str) == "MANIFEST.XML")		this._manifest = total;	    if (word.str == "/") {		if (!exists (total)) {		    std.file.mkdir (total);		}	    }	}    }        override string toString () {		OutBuffer buf = new OutBuffer;	foreach (name, am; archFile.directory) {	    buf.write (name ~ " : ");	    buf.write (to!string (am.expandedSize));	    buf.write ("\n");	}	return buf.toString ();    }        private {		/// l'emplacement ou le desarchivage va etre effectue	immutable string ROOTDIR = "deploy/";	ZipArchive archFile;	string archName;	string _manifest;	string _root;	    }}